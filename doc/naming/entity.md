# 实体类命名规范

## 摘要

* 实体类的定义与来源
* 命名规则

### 实体类的定义与来源

实体类是指在代码中表示客观事物的信息结构的简单类，一般只有对属性的读写操作，很少或者没有业务逻辑，也称模型类，POJO等。一般来讲，这些实体类都是可以序列化和持久化的。像Android中的Intent，尽管数据结构复杂，也有较多的业务逻辑，我们仍然认为它是一个实体类，但是，ActivityInfo这样的复杂类，我们并不认为它是一个实体类。当然，实体类的复杂程度不能“一刀切”，需具体情况具体分析，没有一个绝对的标准。

实体类的来源

* 服务器返回的结构化数据
* 数据库返回的结构化数据
* 表示程序界面某个页面元素对象的结构化数据
* 表示程序中的某个事物，结构或者过程等的结构化数据

### 命名规则

* 根据分类进行命名，添加固定的后缀
* 除后缀外的其它组成部分以驼峰方式连接，最多不超过3个单词，比如“LocalBankAccountEntity”
* 单词不要使用缩写，除非这个缩写是约定俗成也众所周知的，比如Configuration可以缩写成Config，但是Account不能缩写成Acct
* 如果其中一个单词本省就是缩写，比如“HttpResponseEntity”，其中HTTP是一个众所周知的缩写词，要把它作为一个单词看待，首字母大写，其余的小写，不能命名为“HTTPResponseEntity”
* 例外：对于由2个字母组成的缩写单词，比如US（United States）,需要把两个字母都大写，比如“USProductEntity”，而不应该命名为“UsProductEntity”
* 不建议自己创造缩写词，比如把“LocalBankAccountEntity”缩写成“LBAEntity”，除非这个缩写词是众所周知或约定俗成的，如果自己不能判断这个缩写词是“众所周知或约定俗成”的，或者你认为是“众所周知或约定俗成”，但项目组里其它同事确持不同意见，就应当使用全称，而不是缩写。换言之，其他组员对词语是否采用缩写有“一票否决权”

一些固定的后缀

| 后缀            | 含义 |
|----------------|-----------------------------------------------------|
| Parameter      | 表示GET参数
| Form           | 表示POST参数
| Entity         | 表示由服务器返回的结构化数据
| Body           | 表示向服务器上传的结构化数据
| Model          | 表示数据库返回的结构化数据
| Data           | 表示数据库写入的结构化数据
| Item           | 表示程序界面显示某个页面元素所需数据的集合（一般用于数据绑定）
| Struct         | 为了一次返回多个数据而临时的构成的数据结构
| Info           | 表示程序中的某个实体，结构，概念或者过程的结构化数据，一般不使用
| Entry          | 一般不使用
| Part           | 一般不使用
| Bean           | 一般不使用

比如，服务器返回一个表示用户信息的JSON对象，但是这个对象并不是直接表示用户，而是有一定的结构，用来表示返回结果的其它信息，比如错误代码，错误信息等。我们可以把这个JSON对象命名为UserResponseEntity，其中表示用户信息的结构命名为UserEntity（如果这个结构是类，那么UserEntity是类的名称，如果是数组，则是该数组中的对象的名称）；然后，我们把它存储到本地数据库，数据库给它添加了一个id字段作为主键，当我们从数据库中再次把它读出来的时候，命名为UserModel；最后，我们把它显示在界面上，可能又多了一个表示选中或未选中的状态信息，我们再次命名为UserItem。这里，我们不一定使用继承，虽然他们有很多相同的字段（因为早期的Kotlin版本中，数据类就不支持继承）。当然，如果我们从服务器返回的数据对象在写入本地数据库和显示在界面时并没有添加任何多的属性，我们是不需要对这个对象所在的类进行重新命名的。

对于实体类中属性的命名，应该与服务器或者数据库的字段命名完全一致，除非它们的命名在我们的编程语言中并非一个合法的标识符。一个可能出现争议的地方是，如果服务器或数据库中的命名方式为下划线，而我们程序中使用驼峰式，我们直接使用它们的命名会破坏我们代码的风格统一性，特别是我们在我们的代码加入代码扫描验证流程之后，这个问题会非常突出。因此，如果我们特别在意这个问题，我们可以更改对应命名的格式（仅修改格式，不修改字面值）。一种特殊情况是，程序之外的某个数据结构或者其属性的命名与本程序中的关键字相冲突，这时我们不得不修改字面值。常见的字面值修改方式如下表：

| 冲突字          | 含义 |
|----------------|-----------------------------------------------------|
| class          | clazz

另外一种通用的方式是直接添加下划线作为前缀，比如“switch”修改为“_switch”。

对于实体类中存取方法的命名，如果语言支持自动定义，应遵从其自动的定义；如果没有，则遵从Java的通用规范，使用getXXX，setXXX，isXXX，hasXXX等。

如果hashCode()方法被重写，那么equals()一定要重写；同样，如果equals()方法被重写，那么hashCode()一定要重。且这两个方法必须满足：

* equals()返回true时hashCode()必须相等
* hashCode()相等时equals()必须返回true

equals()方法的实现必须满足等价关系：

* 自反性：A.equals(A) == true
* 对称性：A.equals(B) == B.equals(A)
* 传递性：A.equals(B) && B.equals(C) -> A.equals(C)


命名时，最外边的类命名须严格包含上面建议的后缀，嵌套的类可以直接取原来的命名，例如：

```
{
	"code": 200,
	"message": "",
	"error": {
	
	}
}
```
此对象命名为XXXEntity，errorInfo类直接命名为Error即可

